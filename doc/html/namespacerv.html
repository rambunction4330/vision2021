<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vision2021: rv Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vision2021
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rv Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>'Rambunction Vision' namespace to store shared code.  
<a href="namespacerv.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrv_1_1_camera.html">Camera</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The camera properties.  <a href="structrv_1_1_camera.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrv_1_1_target.html">Target</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A target shape and name.  <a href="structrv_1_1_target.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrv_1_1_target_match.html">TargetMatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A contour and it's matching target.  <a href="structrv_1_1_target_match.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrv_1_1_target_pose.html">TargetPose</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The 3d position of a target.  <a href="structrv_1_1_target_pose.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrv_1_1_ball.html">Ball</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ball with a given radius and center.  <a href="structrv_1_1_ball.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrv_1_1_circle.html">Circle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A circle with a given radius and center.  <a href="structrv_1_1_circle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrv_1_1_circle_match.html">CircleMatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A contour and it's closest matching circle.  <a href="structrv_1_1_circle_match.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrv_1_1_ball_pose.html">BallPose</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The estimated position of a ball.  <a href="structrv_1_1_ball_pose.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrv_1_1_threshold.html">Threshold</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structer holding data to threshold an image.  <a href="structrv_1_1_threshold.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:add33f4c9c29ab0d8a3644b3c27fef00c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerv.html#add33f4c9c29ab0d8a3644b3c27fef00c">approximateNGon</a> (std::vector&lt; cv::Point2f &gt; &amp;src, std::vector&lt; cv::Point2f &gt; &amp;dst, int n, double start=0, double end=100, double step=0.1)</td></tr>
<tr class="memdesc:add33f4c9c29ab0d8a3644b3c27fef00c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximates a contour to have n sides.  <a href="namespacerv.html#add33f4c9c29ab0d8a3644b3c27fef00c">More...</a><br /></td></tr>
<tr class="separator:add33f4c9c29ab0d8a3644b3c27fef00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c335f4d1270273193d276c831ce93b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerv.html#a7c335f4d1270273193d276c831ce93b2">reorderPoints</a> (std::vector&lt; cv::Point2f &gt; &amp;points)</td></tr>
<tr class="memdesc:a7c335f4d1270273193d276c831ce93b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders a vector of points to start with the one closest to the origin.  <a href="namespacerv.html#a7c335f4d1270273193d276c831ce93b2">More...</a><br /></td></tr>
<tr class="separator:a7c335f4d1270273193d276c831ce93b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d578188d6dc57fd8258903b18775470"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerv.html#a6d578188d6dc57fd8258903b18775470">normalizedContourImage</a> (std::vector&lt; cv::Point2f &gt; contour, std::vector&lt; cv::Point2f &gt; &amp;projectedContour, cv::Mat &amp;image)</td></tr>
<tr class="memdesc:a6d578188d6dc57fd8258903b18775470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes a contour into a 255x255 binary image.  <a href="namespacerv.html#a6d578188d6dc57fd8258903b18775470">More...</a><br /></td></tr>
<tr class="separator:a6d578188d6dc57fd8258903b18775470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220f3e20536525e38bdf5f1ee863133c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structrv_1_1_target_match.html">rv::TargetMatch</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerv.html#a220f3e20536525e38bdf5f1ee863133c">matchTargetPoints</a> (std::vector&lt; <a class="el" href="structrv_1_1_target_match.html">rv::TargetMatch</a> &gt; &amp;matches)</td></tr>
<tr class="memdesc:a220f3e20536525e38bdf5f1ee863133c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes a match so the contour an target points aline.  <a href="namespacerv.html#a220f3e20536525e38bdf5f1ee863133c">More...</a><br /></td></tr>
<tr class="separator:a220f3e20536525e38bdf5f1ee863133c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98db74b963e7e6a0e5794db8dbcb9ac"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structrv_1_1_target_match.html">rv::TargetMatch</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerv.html#ac98db74b963e7e6a0e5794db8dbcb9ac">findTargets</a> (std::vector&lt; std::vector&lt; cv::Point &gt;&gt; contours, std::vector&lt; <a class="el" href="structrv_1_1_target.html">rv::Target</a> &gt; targets, double minArea, double maxMatch)</td></tr>
<tr class="memdesc:ac98db74b963e7e6a0e5794db8dbcb9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the targets that best matches each contour.  <a href="namespacerv.html#ac98db74b963e7e6a0e5794db8dbcb9ac">More...</a><br /></td></tr>
<tr class="separator:ac98db74b963e7e6a0e5794db8dbcb9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae79a3606c2fbb9648e7753b500bca6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structrv_1_1_target_pose.html">rv::TargetPose</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerv.html#a9ae79a3606c2fbb9648e7753b500bca6">estimateTargetPose</a> (std::vector&lt; <a class="el" href="structrv_1_1_target_match.html">TargetMatch</a> &gt; matches, cv::Mat cameraMatrix, cv::Mat distortion)</td></tr>
<tr class="memdesc:a9ae79a3606c2fbb9648e7753b500bca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the target position using a solvePnP.  <a href="namespacerv.html#a9ae79a3606c2fbb9648e7753b500bca6">More...</a><br /></td></tr>
<tr class="separator:a9ae79a3606c2fbb9648e7753b500bca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3acf99edf6e62ac9fc6246aafefda837"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structrv_1_1_circle_match.html">rv::CircleMatch</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerv.html#a3acf99edf6e62ac9fc6246aafefda837">findCircles</a> (std::vector&lt; std::vector&lt; cv::Point &gt;&gt; contours, double minArea, double minMatch)</td></tr>
<tr class="memdesc:a3acf99edf6e62ac9fc6246aafefda837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the closest matchng circle of a contour.  <a href="namespacerv.html#a3acf99edf6e62ac9fc6246aafefda837">More...</a><br /></td></tr>
<tr class="separator:a3acf99edf6e62ac9fc6246aafefda837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e735278274200ba60ec90b0c68b687"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structrv_1_1_ball_pose.html">rv::BallPose</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerv.html#ae2e735278274200ba60ec90b0c68b687">estimateBallPose</a> (std::vector&lt; <a class="el" href="structrv_1_1_circle_match.html">CircleMatch</a> &gt; circles, <a class="el" href="structrv_1_1_ball.html">rv::Ball</a> ball, cv::Mat cameraMatrix, cv::Mat distortion)</td></tr>
<tr class="memdesc:ae2e735278274200ba60ec90b0c68b687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the position of a ball.  <a href="namespacerv.html#ae2e735278274200ba60ec90b0c68b687">More...</a><br /></td></tr>
<tr class="separator:ae2e735278274200ba60ec90b0c68b687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6a9178f14c8d3023439de0a50ab4ad"><td class="memTemplParams" colspan="2">template&lt;typename _OutType , typename _InType &gt; </td></tr>
<tr class="memitem:aaf6a9178f14c8d3023439de0a50ab4ad"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; cv::Point_&lt; _OutType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerv.html#aaf6a9178f14c8d3023439de0a50ab4ad">convertToPoints</a> (std::vector&lt; cv::Point_&lt; _InType &gt;&gt; &amp;input)</td></tr>
<tr class="memdesc:aaf6a9178f14c8d3023439de0a50ab4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a vector of 2 dimensional point to another type.  <a href="namespacerv.html#aaf6a9178f14c8d3023439de0a50ab4ad">More...</a><br /></td></tr>
<tr class="separator:aaf6a9178f14c8d3023439de0a50ab4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ff278e0d2ace923cc0f26a8e9a8fa6"><td class="memTemplParams" colspan="2">template&lt;typename _OutType , typename _InType &gt; </td></tr>
<tr class="memitem:a41ff278e0d2ace923cc0f26a8e9a8fa6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; cv::Point_&lt; _OutType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerv.html#a41ff278e0d2ace923cc0f26a8e9a8fa6">convertToPoints</a> (std::vector&lt; cv::Point3_&lt; _InType &gt;&gt; &amp;input)</td></tr>
<tr class="memdesc:a41ff278e0d2ace923cc0f26a8e9a8fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a vector of 3 dimensional point to another type.  <a href="namespacerv.html#a41ff278e0d2ace923cc0f26a8e9a8fa6">More...</a><br /></td></tr>
<tr class="separator:a41ff278e0d2ace923cc0f26a8e9a8fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e264e3f8ba5ae966d62731fa281403"><td class="memTemplParams" colspan="2">template&lt;typename _OutType , typename _InType &gt; </td></tr>
<tr class="memitem:ab5e264e3f8ba5ae966d62731fa281403"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; cv::Point3_&lt; _OutType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerv.html#ab5e264e3f8ba5ae966d62731fa281403">convertToPoints3</a> (std::vector&lt; cv::Point_&lt; _InType &gt;&gt; &amp;input)</td></tr>
<tr class="memdesc:ab5e264e3f8ba5ae966d62731fa281403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a vector of 3 dimensional point to another type.  <a href="namespacerv.html#ab5e264e3f8ba5ae966d62731fa281403">More...</a><br /></td></tr>
<tr class="separator:ab5e264e3f8ba5ae966d62731fa281403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55cab25c6afe2c44019fc440cb4ec48"><td class="memTemplParams" colspan="2">template&lt;typename _OutType , typename _InType &gt; </td></tr>
<tr class="memitem:ac55cab25c6afe2c44019fc440cb4ec48"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; cv::Point3_&lt; _OutType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerv.html#ac55cab25c6afe2c44019fc440cb4ec48">convertToPoints3</a> (std::vector&lt; cv::Point3_&lt; _InType &gt;&gt; &amp;input)</td></tr>
<tr class="memdesc:ac55cab25c6afe2c44019fc440cb4ec48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a vector of 3 dimensional point to another type.  <a href="namespacerv.html#ac55cab25c6afe2c44019fc440cb4ec48">More...</a><br /></td></tr>
<tr class="separator:ac55cab25c6afe2c44019fc440cb4ec48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c38df19fa94167506698615d6e21fa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerv.html#a9c38df19fa94167506698615d6e21fa8">thresholdImage</a> (cv::Mat &amp;src, cv::Mat &amp;dst, <a class="el" href="structrv_1_1_threshold.html">rv::Threshold</a> threshold)</td></tr>
<tr class="memdesc:a9c38df19fa94167506698615d6e21fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thresholds an image in the HSV color space.  <a href="namespacerv.html#a9c38df19fa94167506698615d6e21fa8">More...</a><br /></td></tr>
<tr class="separator:a9c38df19fa94167506698615d6e21fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744b2fbe7efa0fca0ca2a833067a3571"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerv.html#a744b2fbe7efa0fca0ca2a833067a3571">extractImagesFromDirectory</a> (std::string filepath, std::vector&lt; cv::Mat &gt; &amp;images)</td></tr>
<tr class="memdesc:a744b2fbe7efa0fca0ca2a833067a3571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracs all the image files from a given directory.  <a href="namespacerv.html#a744b2fbe7efa0fca0ca2a833067a3571">More...</a><br /></td></tr>
<tr class="separator:a744b2fbe7efa0fca0ca2a833067a3571"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>'Rambunction Vision' namespace to store shared code. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="add33f4c9c29ab0d8a3644b3c27fef00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add33f4c9c29ab0d8a3644b3c27fef00c">&#9670;&nbsp;</a></span>approximateNGon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rv::approximateNGon </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; cv::Point2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cv::Point2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>end</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>step</em> = <code>0.1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Approximates a contour to have n sides. </p>
<p>The function iterativly attempts aproximations with a higher error untill one is found with n sides.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The input points. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>The output Points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The target number of sides. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>The guess to start with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>The guess to end with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step</td><td>The change in error between each iteration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if a correct approimation is found. </dd>
<dd>
false, if no such approximation can be found.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacerv.html#a220f3e20536525e38bdf5f1ee863133c" title="Processes a match so the contour an target points aline.">matchTargetPoints</a> </dd></dl>

</div>
</div>
<a id="a41ff278e0d2ace923cc0f26a8e9a8fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ff278e0d2ace923cc0f26a8e9a8fa6">&#9670;&nbsp;</a></span>convertToPoints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _OutType , typename _InType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;cv::Point_&lt;_OutType&gt; &gt; rv::convertToPoints </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; cv::Point3_&lt; _InType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a vector of 3 dimensional point to another type. </p>
<p>The x and y parts of the output are identical to the input, just with a diffrent numeric type. The z component is truncated.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_OutType</td><td>The numeric type of points to convert to. </td></tr>
    <tr><td class="paramname">_InType</td><td>The numeric type that the points are being converted from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input vector of points to be converted to another type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;cv::Point_&lt;_OutType&gt;&gt; The output converted points. </dd></dl>

</div>
</div>
<a id="aaf6a9178f14c8d3023439de0a50ab4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6a9178f14c8d3023439de0a50ab4ad">&#9670;&nbsp;</a></span>convertToPoints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _OutType , typename _InType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;cv::Point_&lt;_OutType&gt; &gt; rv::convertToPoints </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; cv::Point_&lt; _InType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a vector of 2 dimensional point to another type. </p>
<p>The output is identical to the input, just with a diffrent numeric type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_OutType</td><td>The numeric type of points to convert to. </td></tr>
    <tr><td class="paramname">_InType</td><td>The numeric type that the points are being converted from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input vector of points to be converted to another type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;cv::Point_&lt;_OutType&gt;&gt; The output converted points. </dd></dl>

</div>
</div>
<a id="ac55cab25c6afe2c44019fc440cb4ec48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac55cab25c6afe2c44019fc440cb4ec48">&#9670;&nbsp;</a></span>convertToPoints3() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _OutType , typename _InType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;cv::Point3_&lt;_OutType&gt; &gt; rv::convertToPoints3 </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; cv::Point3_&lt; _InType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a vector of 3 dimensional point to another type. </p>
<p>The output points are identical to int input in all but which numeric type they use.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_OutType</td><td>The numeric type of points to convert to. </td></tr>
    <tr><td class="paramname">_InType</td><td>The numeric type that the points are being converted from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input vector of points to be converted to another type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;cv::Point3_&lt;_OutType&gt;&gt; The output converted points. </dd></dl>

</div>
</div>
<a id="ab5e264e3f8ba5ae966d62731fa281403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e264e3f8ba5ae966d62731fa281403">&#9670;&nbsp;</a></span>convertToPoints3() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _OutType , typename _InType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;cv::Point3_&lt;_OutType&gt; &gt; rv::convertToPoints3 </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; cv::Point_&lt; _InType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a vector of 3 dimensional point to another type. </p>
<p>The x and y parts of the output are identical to the input, just with a diffrent numeric type. The z component is set to 0.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_OutType</td><td>The numeric type of points to convert to. </td></tr>
    <tr><td class="paramname">_InType</td><td>The numeric type that the points are being converted from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input vector of points to be converted to another type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;cv::Point3_&lt;_OutType&gt;&gt; The output converted points. </dd></dl>

</div>
</div>
<a id="ae2e735278274200ba60ec90b0c68b687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e735278274200ba60ec90b0c68b687">&#9670;&nbsp;</a></span>estimateBallPose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structrv_1_1_ball_pose.html">rv::BallPose</a> &gt; rv::estimateBallPose </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structrv_1_1_circle_match.html">CircleMatch</a> &gt;&#160;</td>
          <td class="paramname"><em>circles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrv_1_1_ball.html">rv::Ball</a>&#160;</td>
          <td class="paramname"><em>ball</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>cameraMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>distortion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimates the position of a ball. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">circles</td><td>The circles to find the position of. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ball</td><td>The size of the balls to find the position of. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cameraMatrix</td><td>The intrnsic camera matrix for 2d-3d corospondence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distortion</td><td>The coefficents to acount for lense distortion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;rv::BallPose&gt; The output positions of the balls</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structrv_1_1_circle_match.html" title="A contour and it&#39;s closest matching circle.">CircleMatch</a> <a class="el" href="structrv_1_1_ball_pose.html" title="The estimated position of a ball.">BallPose</a> <a class="el" href="namespacerv.html#a3acf99edf6e62ac9fc6246aafefda837" title="Find the closest matchng circle of a contour.">findCircles</a> Cirlce <a class="el" href="structrv_1_1_ball.html" title="A ball with a given radius and center.">Ball</a> </dd></dl>

</div>
</div>
<a id="a9ae79a3606c2fbb9648e7753b500bca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae79a3606c2fbb9648e7753b500bca6">&#9670;&nbsp;</a></span>estimateTargetPose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structrv_1_1_target_pose.html">rv::TargetPose</a> &gt; rv::estimateTargetPose </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structrv_1_1_target_match.html">TargetMatch</a> &gt;&#160;</td>
          <td class="paramname"><em>matches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>cameraMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>distortion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimates the target position using a solvePnP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matches</td><td>Input matches to solve the position for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cameraMatrix</td><td>The intrnsic camera matrix for 2d-3d corospondence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distortion</td><td>The coefficents to acount for lense distortion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;rv::TargetPose&gt; The matches along with thier solved position.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structrv_1_1_target_match.html" title="A contour and it&#39;s matching target.">TargetMatch</a> <a class="el" href="structrv_1_1_target_pose.html" title="The 3d position of a target.">TargetPose</a> </dd></dl>

</div>
</div>
<a id="a744b2fbe7efa0fca0ca2a833067a3571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744b2fbe7efa0fca0ca2a833067a3571">&#9670;&nbsp;</a></span>extractImagesFromDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rv::extractImagesFromDirectory </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cv::Mat &gt; &amp;&#160;</td>
          <td class="paramname"><em>images</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracs all the image files from a given directory. </p>
<p>Iterates over a directory and tries to extract each file as an image. All files that can be read by OpenCV are added to the vector, while all otehrs are skiped. The iteration is not recursive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>The filepath to the directory with the images. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">images</td><td>The output vector of images in the directory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false, if the filepath can't be found. </dd></dl>

</div>
</div>
<a id="a3acf99edf6e62ac9fc6246aafefda837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3acf99edf6e62ac9fc6246aafefda837">&#9670;&nbsp;</a></span>findCircles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structrv_1_1_circle_match.html">rv::CircleMatch</a> &gt; rv::findCircles </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; cv::Point &gt;&gt;&#160;</td>
          <td class="paramname"><em>contours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minMatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the closest matchng circle of a contour. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">contours</td><td>The input contours to be matched with circles. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minArea</td><td>The minimum allowable contour area. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minMatch</td><td>The minimum allowable match value (0.0-1.0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;rv::CircleMatch&gt; The output contours matched with thier closest matching circle.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structrv_1_1_circle.html" title="A circle with a given radius and center.">Circle</a> <a class="el" href="structrv_1_1_circle_match.html" title="A contour and it&#39;s closest matching circle.">CircleMatch</a> <a class="el" href="namespacerv.html#ae2e735278274200ba60ec90b0c68b687" title="Estimates the position of a ball.">estimateBallPose</a> <a class="el" href="structrv_1_1_ball.html" title="A ball with a given radius and center.">Ball</a> <a class="el" href="structrv_1_1_ball_pose.html" title="The estimated position of a ball.">BallPose</a> </dd></dl>

</div>
</div>
<a id="ac98db74b963e7e6a0e5794db8dbcb9ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98db74b963e7e6a0e5794db8dbcb9ac">&#9670;&nbsp;</a></span>findTargets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structrv_1_1_target_match.html">rv::TargetMatch</a> &gt; rv::findTargets </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; cv::Point &gt;&gt;&#160;</td>
          <td class="paramname"><em>contours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structrv_1_1_target.html">rv::Target</a> &gt;&#160;</td>
          <td class="paramname"><em>targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxMatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the targets that best matches each contour. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">contours</td><td>The input contours to be matched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targets</td><td>The targets to match the contours against. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minArea</td><td>The minimum contour area allowable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxMatch</td><td>The mamatch value allowable (lower is better). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;rv::TargetMatch&gt; The paired up contours and targets.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structrv_1_1_target.html" title="A target shape and name.">Target</a> <a class="el" href="structrv_1_1_target_match.html" title="A contour and it&#39;s matching target.">TargetMatch</a> </dd></dl>

</div>
</div>
<a id="a220f3e20536525e38bdf5f1ee863133c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220f3e20536525e38bdf5f1ee863133c">&#9670;&nbsp;</a></span>matchTargetPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structrv_1_1_target_match.html">rv::TargetMatch</a> &gt; rv::matchTargetPoints </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structrv_1_1_target_match.html">rv::TargetMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matches</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Processes a match so the contour an target points aline. </p>
<p>Both the target and contour are transformed to fit in a 255x255 square. They are then drawn and their overlap is calculated at each orintation so they will have matching orientation. The contour points are simplifyed to have the same number of sides as the target, and the points of each are reordered to assure corospondence becofre being transformed back to thier origional position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matches</td><td>The input vector of matches. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;rv::TargetMatch&gt; the ouput processed matches.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structrv_1_1_target_match.html" title="A contour and it&#39;s matching target.">TargetMatch</a> <a class="el" href="namespacerv.html#a6d578188d6dc57fd8258903b18775470" title="Normalizes a contour into a 255x255 binary image.">normalizedContourImage</a> <a class="el" href="namespacerv.html#add33f4c9c29ab0d8a3644b3c27fef00c" title="Approximates a contour to have n sides.">approximateNGon</a> <a class="el" href="namespacerv.html#a7c335f4d1270273193d276c831ce93b2" title="Reorders a vector of points to start with the one closest to the origin.">reorderPoints</a> </dd></dl>

</div>
</div>
<a id="a6d578188d6dc57fd8258903b18775470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d578188d6dc57fd8258903b18775470">&#9670;&nbsp;</a></span>normalizedContourImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat rv::normalizedContourImage </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; cv::Point2f &gt;&#160;</td>
          <td class="paramname"><em>contour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cv::Point2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>projectedContour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes a contour into a 255x255 binary image. </p>
<p>A rotated bounding box of the contour is found, and the points are transformed such that the box becomes the image frame. The contour is then drawn onto the image filled. This can then be used for an improved shape match value and orientation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">contour</td><td>The input contour to be normalized. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">projectedContour</td><td>The output points of the contour after being transformed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">image</td><td>The ouput binary image of the transformed points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cv::Mat The matrix used to transform the points into the image.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacerv.html#a220f3e20536525e38bdf5f1ee863133c" title="Processes a match so the contour an target points aline.">matchTargetPoints</a> </dd></dl>

</div>
</div>
<a id="a7c335f4d1270273193d276c831ce93b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c335f4d1270273193d276c831ce93b2">&#9670;&nbsp;</a></span>reorderPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rv::reorderPoints </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; cv::Point2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorders a vector of points to start with the one closest to the origin. </p>
<p>The vector is rotated so the point closest to the origin is first. If the points are in a counter-clockwise order, they will be corrected to a clockwise order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">points</td><td>The point to be reorder.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacerv.html#a220f3e20536525e38bdf5f1ee863133c" title="Processes a match so the contour an target points aline.">matchTargetPoints</a> </dd></dl>

</div>
</div>
<a id="a9c38df19fa94167506698615d6e21fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c38df19fa94167506698615d6e21fa8">&#9670;&nbsp;</a></span>thresholdImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rv::thresholdImage </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrv_1_1_threshold.html">rv::Threshold</a>&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thresholds an image in the HSV color space. </p>
<p>The function fist blurs the image, then the image is then converted into the HSV color space to be thresheld. After thresholding, two morphalogical operations are applied to close any holes and remove noise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The input image. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>The output thresheld image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>The parameters to threshold the image by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structrv_1_1_threshold.html" title="Structer holding data to threshold an image.">Threshold</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
